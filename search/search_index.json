{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-eungabi","title":"What is Eungabi?","text":"<p>Eungabi is a Compose Multiplatform Navigation library that supports Platform Native Features like Predictive Back Gesture(Android), Swipe-Back Gesture(iOS), Shared Element Transition(Common). This library adopts a screen transition pattern based on NavHost, similar to the Jetpack Navigation library. A key difference is that it allows for customization of the Predictive Back animation separately.</p>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code></li> <li><code>ios</code></li> <li><code>web</code> (<code>IR</code> and <code>Wasm</code>)</li> <li><code>desktop</code> (<code>jvm</code> and <code>macOS</code>)</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2024 easternkite\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#eungabi-core-module","title":"Eungabi Core Module","text":"<p>you can simply use main functionalities of <code>Eungabi</code> navigation. </p> GroovyKotlin <pre><code>implementation \"io.github.easternkite:eungabi:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"io.github.easternkite:eungabi:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This section describes how to quickly get started with <code>Eungabi</code>. </p>"},{"location":"getting-started/quick-start/#1-create-navigation-controller","title":"1. Create Navigation Controller.","text":"<p>The navigation Controller(<code>EunGabiController</code>) holds the navigation graph and provides methods that allow your app to move between the destinations you want by controlling backStack.</p> <p>To create a <code>EunGabiController</code> in composable function, call <code>rememberEunGabiController</code></p> <pre><code>val controller = rememberEunGabiController()\n</code></pre> <p>Warning</p> <p>You must use <code>EunGabiController</code> with <code>EunGabiNavHost</code>, as described in the next section, by passing it as a parameter.</p> <p>There are two key methods you should know: <code>navigate</code>, <code>navigateUp</code> <code>navigate</code> allows you to navigate to the next screen by adding the provided route to the back stack. <code>navigateUp</code> allows you to navigate to the previous screen by removing a latest entry(or entries) from the back stack.</p>"},{"location":"getting-started/quick-start/#2-create-a-navigation-host-composable","title":"2. Create a Navigation Host Composable","text":"<p>The <code>EunGabiNavHost</code> creates a navigation graph and displays the current entry of the back stack. By using this, you can define and control your desired routes.</p> <p>you can simply call <code>EunGabiNavHost</code> in the composable function to create a navigation host.</p> <pre><code>val controller = rememberEunGabiController()\nEunGabiNavHost(\n    modifier = Modifier,\n    controller = controller,\n    startDestination = \"routeA\",\n) {\n    composable(\"routeA\") {\n        MainComponent(\"routeA\") {\n            controller.navigate(\"routeB\")\n        }\n    }\n    composable(\"routeB\") {\n        DetailsComponent(\n            \"routeB\",\n            onNavigateBack = controller::navigateUp\n        ) {\n            egController.navigate(\"routeC\")\n        }\n    }\n    //...\n}\n</code></pre> <p>The process of displaying a screen to the user</p> <ol> <li>The call to the <code>EunGabiNavHost</code> composable passes a <code>EunGabiController</code> and a route for the start destination.  </li> <li>The lambda passed to the <code>EunGabiNavHost</code> creates <code>EunGabiGraph</code> and set the graph to the <code>EunGabiController.graph</code> </li> <li>Each route is supplied as a <code>EunGabiDestination</code> by calling <code>EunGabiGraphBuilder.composable()</code> which adds the destination to the resulting <code>EunGabiGraph</code> described at 2.  </li> <li>The lambda passed to <code>composable()</code> is what the <code>EunGabiNavHost</code> displays for that destination.</li> </ol>"},{"location":"navigation/animate-transitions-between-destinations/","title":"Animate transitions between destinations","text":"<p>You can customize transition animations during navigation. To do so, pass an <code>EunGabiTransitionState</code> instance to the <code>EunGabiNavHost</code> as a parameter.</p> <p>The following snippets demonstrate how to animate screens with a horizontal slide during navigation.</p> <pre><code>// 1. declare EunGabiTransitionState\nval defaultTransition =  \n    EunGabiTransitionState(  \n        enter = {  \n            slideInHorizontally(  \n                animationSpec = tween(300),  \n                initialOffsetX = { fullWidth -&gt; fullWidth },  \n            )  \n        },  \n        exit = {  \n            slideOutHorizontally(  \n                tween(durationMillis = 300),  \n                targetOffsetX = { fullWidth -&gt; -fullWidth / 4 },  \n            )  \n        },  \n        popEnter = {  \n            slideInHorizontally(  \n                animationSpec = tween(300),  \n                initialOffsetX = { fullWidth -&gt; -fullWidth / 4 },  \n            )  \n        },  \n        popExit = {  \n            slideOutHorizontally(  \n                tween(durationMillis = 300),  \n                targetOffsetX = { fullWidth -&gt; fullWidth },  \n            )  \n        },  \n    )\n\n\n// 2. pass the 'defaultDransition' to the EunGabiNavHost as a parameter.\nfun App() {\n    EunGabiNavHost(\n        //...\n        transitionState = defaultTransition\n    ) { ... }\n}\n</code></pre> <p>The outcome is as follows: </p> <p>Tip</p> <p>Eungabi's transition animation mechanism works almost identically to the Jetpack Navigation library. For more details, please refer to the official docs .</p>"},{"location":"navigation/animate-transitions-between-destinations/#predictive-back-swipe-back-gesture","title":"Predictive back &amp; Swipe back gesture","text":"<p>You can also customize the Predictive back animation, which is a navigation feature that lets users preview where the back swipe will take them. It currently supports only Android and iOS.</p> <p>To do so, pass an <code>EunGabiPredictiveState</code> instance to the <code>EunGabiNavHost</code> as a parameter.</p>"},{"location":"navigation/animate-transitions-between-destinations/#on-android","title":"On Android","text":"<p>On Android, Predictive back gesture officially supports since the Android 15.</p> <p>To customize predictve back animation, in\u00a0<code>AndroidManifest.xml</code>, in the\u00a0<code>&lt;application&gt;</code>\u00a0tag, set the\u00a0<code>android:enableOnBackInvokedCallback</code>\u00a0flag to\u00a0<code>true</code>. <pre><code>&lt;application\n    ...\n    android: enableOnBackInvokedCallBack = \"true\"\n    ... &gt;\n&lt;/application&gt;\n</code></pre></p> <p>And then, pass an <code>EunGabiPredictiveState</code> instance to the <code>EunGabiNavHost</code> as a parameter.</p> <pre><code>val defaultPredictiveState = EunGabiPredictiveState(  \n    popEnter = { fadeIn(animationSpec = tween(700)) },  \n    popExit = { fadeOut(animationSpec = tween(700)) }\n)\n\nfun App() {\n    EunGabiNavHost(\n        //...\n        predictiveBackTransition = defaultPredictiveState\n    ) { ... }\n}\n</code></pre> <p>The outcome is as follows: </p>"},{"location":"navigation/animate-transitions-between-destinations/#on-ios","title":"On iOS","text":"<p>On iOS, Eungabi now supports Native-Like Swipe back transition. To do so, also pass an <code>EunGabiPredictiveState</code> instance to the <code>EunGabiNavHost</code> as a parameter.</p> <pre><code>val iosPredictiveBack =  \n    EunGabiPredictiveState(  \n        popEnter = {  \n            slideInHorizontally(  \n                animationSpec = tween(1000, easing = LinearEasing),  \n                initialOffsetX = { fullWidth -&gt; -fullWidth / 4 },  \n            )  \n        },  \n        popExit = {  \n            slideOutHorizontally(  \n                tween(durationMillis = 1000, easing = LinearEasing),  \n                targetOffsetX = { fullWidth -&gt; fullWidth },  \n            )  \n        },  \n    )\n\nfun App() {\n    EunGabiNavHost(\n        //...\n        predictiveBackTransition = iosPredictiveBack\n    ) { ... }\n}\n</code></pre> <p>Tip</p> <p>It is important to set the duration of each animation spec to 1000 milliseconds. The reason for this is to ensure that the screen being transitioned moves in perfect sync with the user's finger.</p> <p>The outcome is as follows: </p>"},{"location":"navigation/animate-transitions-between-destinations/#shared-element-transitions","title":"Shared Element Transitions","text":"<p>Eungabi also supports the Shared Element Transitions for all supported targets. The <code>composable()</code> function in <code>EunGabiNavHost</code> provides an AnimatedVisibilityScope receiver to the content composable block, enabling Shared Element Transitions. For a more detailed guide on Shared Element Transitions, see <code>Shared Element Transitions</code>.</p>"},{"location":"navigation/navigate-between-composables/","title":"Navigate between composables","text":""},{"location":"navigation/navigate-between-composables/#use-a-eungabicontroller","title":"Use a EunGabiController","text":"<p>The <code>EunGabiController</code> provides ways to navigate between composables. See the Create Navigation Controller section for instructions on instantiating the <code>EunGabiController</code>.</p> <pre><code>val controller = rememberEunGabiController()\n</code></pre>"},{"location":"navigation/navigate-between-composables/#navigate-to-a-composable","title":"Navigate to a Composable","text":"<p>To navigate to a composable, you should call the <code>EunGabiController.navigate</code>. <code>navigate()</code> takes a route defined in the <code>EunGabiGraphBuilder</code> of <code>EunGabiNavHost</code>.  See Create a Navigation Host Composable section for instructions on creating a <code>EunGabiGraph</code>.</p> <pre><code>controller.navigate(\"ScreenA\")\n</code></pre> <p>By calling this, you can navigate to the <code>ScreenA</code> route.</p>"},{"location":"navigation/navigate-between-composables/#pop-up-to-a-destination","title":"Pop up to a destination","text":"<p>To remove destinations from the back stack when navigating from one destination to another, add a <code>popUpTo()</code> argument to the associated <code>navigate()</code> function call.</p> <p>You can include an argument for the <code>inclusive</code> option with a value of <code>true</code> to also pop up a destination you have specified in <code>popUpTo()</code>.</p> <p>Let's assume we have screens A, B, C, and D in the back stack. The following snippets demonstrate how to pop up to the <code>ScreenA</code> when navigating up from <code>ScreenD</code>: <pre><code>controller.navigate(\"ScreenD\") {\n    popUpTo(\"ScreenB\") {\n        inclusive = true\n    }\n}\n</code></pre></p> <p>Tip</p> <p>If the <code>inclusive</code> option were <code>false</code>, the result would be a pop-up to <code>ScreenB</code>.</p>"},{"location":"navigation/navigate-between-composables/#navigate-back","title":"Navigate back","text":"<p>You can navigate to the previous screen by calling <code>NavController.navigateUp</code>. It returns a <code>Boolean</code> value  indicating the success of the back navigation. <pre><code>controller.navigateUp()\n</code></pre></p>"},{"location":"navigation/passing-arguments/","title":"Passing Arguments","text":""},{"location":"navigation/passing-arguments/#passing-arguments_1","title":"Passing Arguments","text":"<p>you can simply pass arguments by adding query parameter when calling <code>navigate</code> function. For example : <pre><code>controller.navigate(\"ScreenA?id=111\")\n</code></pre></p> <p>Then, you can access the passed arguments within a composable function defined in <code>EungabiGraphBuilder</code>. For example : <pre><code>fun EunGabiGraphBuilder.aScreenRoute() {\n    composable(\"ScreenA\") {\n        val id = it.arguments.getString(\"id\")\n        Screen(id = id)\n    }\n}\n</code></pre></p>"},{"location":"navigation/passing-arguments/#4passing-complex-arguments-in-urls","title":"4.Passing complex arguments in URLs","text":"<p>You can pass complex arguments, such as multi-parameter URLs, by enclosing them within curly braces (<code>{</code>, <code>}</code>). This allows you to include special characters and multiple parameters within a single URL argument.</p> <p>For example: <pre><code>val fullRoute =  \n    \"ScreenA?url1={https://easternkite.github.io?param1=value1&amp;param2=value2}&amp;url2={https://easternkite.github.io?param1=value1&amp;param2=value2}&amp;id=123\"\ncontroller.navigate(fullRoute)\n\nfun EunGabiGraphBuilder.aScreenRoute() {\n    composable(\"ScreenA\") {\n        val id = it.arguments.getString(\"url1\") // it will be \"https://easternkite.github.io?param1=value1&amp;param2=value2\"\n        Screen(id = id)\n    }\n}\n</code></pre></p>"},{"location":"navigation/saved-state-handle-integration/","title":"SavedStateHandle Integration","text":"<p>eungabi 0.4.0 introduces a powerful SavedState mechanism, enabling seamless state preservation and data transfer in conjunction with ViewModels. With this new feature, each ViewModel can now access a <code>SavedStateHandle</code> object, a key-value map that allows you to store and retrieve data directly within the ViewModel. Crucially, the data within the ViewModelSavedState persists even through process termination and configuration changes, ensuring that your ViewModel's state remains intact.</p>"},{"location":"navigation/saved-state-handle-integration/#using-savedstatehandle-in-eungabi","title":"Using SavedStateHandle in EunGabi","text":"<p>EunGabi provides several convenient ways to utilize <code>SavedStateHandle</code> for managing state across navigation events. Here are the primary methods:</p>"},{"location":"navigation/saved-state-handle-integration/#1-accessing-savedstatehandle-via-eungabicontroller","title":"1. Accessing SavedStateHandle via <code>EunGabiController</code>","text":"<p>You can access the <code>SavedStateHandle</code> of a specific <code>EunGabiEntry</code> by leveraging the <code>EunGabiController.backStack</code>. This allows you to retrieve the <code>SavedStateHandle</code> from any entry within the navigation back stack. <pre><code>val controller = rememberEunGabiController()\nval backStack by controller.backStack. collectAsState()\nval handle = backStack.last().savedStateHandle \nval viewModel = viewModel { ViewModel(handle) }\n</code></pre></p> <p>Explanation: * <code>rememberEunGabiController()</code>: Retrieves the current <code>EunGabiController</code> instance. * <code>controller.backStack.collectAsState()</code>: Collects the current state of the back stack as a <code>State</code> object. * <code>backStack.last().savedStateHandle</code>: Accesses the <code>SavedStateHandle</code> of the most recent entry in the back stack. * <code>viewModel { ViewModel(handle) }</code>: Creates a ViewModel instance with the SavedStateHandle.</p>"},{"location":"navigation/saved-state-handle-integration/#2-accessing-savedstatehandle-within-navgraphbuildercomposable","title":"2. Accessing SavedStateHandle within <code>NavGraphBuilder.composable()</code>","text":"<p>Within the content block of <code>NavGraphBuilder.composable()</code>, you can directly access the <code>SavedStateHandle</code> of the current <code>EunGabiEntry</code>. <pre><code>NavHost(...) { \n    composable(...) { entry -&gt; \n        val handle = entry.savedStateHandle\n        val viewModel = viewModel { ViewModel(handle) } \n    }\n}\n</code></pre></p> <p>Explanation:</p> <ul> <li><code>composable(...) { entry -&gt; ... }</code>: The <code>composable</code> function provides the current <code>EunGabiEntry</code> as a parameter.</li> <li><code>entry.savedStateHandle</code>: Directly accesses the <code>SavedStateHandle</code> associated with the current entry.</li> <li><code>viewModel { ViewModel(handle) }</code>: Creates a ViewModel instance with the SavedStateHandle.</li> </ul>"},{"location":"navigation/saved-state-handle-integration/#3-using-parameter-default-values-with-eungabiviewmodel","title":"3. Using Parameter Default Values with <code>eunGabiViewModel()</code>","text":"<p>For a more streamlined approach, you can use the <code>eunGabiViewModel(...)</code> function to inject the <code>SavedStateHandle</code> directly into your composable function's parameters.</p> <p><code>eunGabiViewModel</code> automatically recognizes the currently active <code>EunGabiEntry</code> and provides the corresponding <code>SavedStateHandle</code>.</p> <pre><code>@Composable \nfun EunGabiScreen( \n    viewModel: EunGabiViewModel = eunGabiViewModel { handle -&gt; EunGabiViewModel(handle) }\n) { ... }\n</code></pre> <p>Explanation:</p> <ul> <li><code>eunGabiViewModel { handle -&gt; EunGabiViewModel(handle) }</code>: This function automatically provides the correct <code>SavedStateHandle</code> to the lambda, which you can then use to create your <code>EunGabiViewModel</code>.</li> <li><code>EunGabiViewModel(handle)</code>: Creates a EunGabiViewModel instance with the SavedStateHandle.</li> </ul>"},{"location":"navigation/saved-state-handle-integration/#hilt-integration","title":"Hilt Integration","text":"<p>When using Hilt in your Android target, you can seamlessly inject the appropriate <code>SavedStateHandle</code> using <code>hiltViewModel()</code>.</p> <p><pre><code>@Composable  \nfun HiltView(viewModel: HiltViewModel = hiltViewModel()) {  \n    val state by viewModel.state.collectAsState()  \n    Text(text = state, modifier = Modifier.testTag(\"state\"))  \n}\n</code></pre> Explanation:</p> <ul> <li><code>hiltViewModel()</code>: This Hilt function automatically provides the correct <code>SavedStateHandle</code> to your <code>HiltViewModel</code>.</li> <li><code>viewModel.state.collectAsState()</code>: Collects the current state of the ViewModel.</li> </ul> <p>Tip</p> <p>For a practical example of Hilt integration, refer to the EunGabiHiltTest.kt file in the EunGabi repository.</p>"},{"location":"navigation/saved-state-handle-integration/#koin-integration","title":"Koin Integration","text":"<p>Similarly, when using Koin in your KMP project, you can easily inject the <code>SavedStateHandle</code> using <code>koinViewModel()</code>. Koin, like Hilt, internally recognizes the current entry and provides the correct <code>SavedStateHandle</code>.</p> <pre><code>@Composable  \nfun KoinView(  \n    viewModel: KoinViewModel = koinViewModel()  \n) {  \n    val state by viewModel.state.collectAsState()  \n    Text(text = state, modifier = Modifier.testTag(\"state\"))  \n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>koinViewModel()</code>: This Koin function automatically provides the correct <code>SavedStateHandle</code> to your <code>KoinViewModel</code>.</li> <li><code>viewModel.state.collectAsState()</code>: Collects the current state of the ViewModel.</li> </ul> <p>Tip</p> <p>For a practical example of Koin integration, refer to the KoinViewModelTest.kt file in the EunGabi repository.  </p>"}]}